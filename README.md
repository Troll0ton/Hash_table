# Hash_table
Данный проект нацелен на изучение принципов работы хэш-таблиц, сравнение различных хэш-функций и изучение их поведения на конкретных наборах данных, развитие практических навыков при работе с профайлингом, в применении оптимизаций на различных уровнях. Важной составляющей исследовательской работы является написание README, объёмно отражающей ход проделанной на всех этапах работы.

![kek][me before hash table laba]

[kek]: https://github.com/Troll0ton/Alpha_blending/blob/main/kek.jpg

---

## Первая часть
Первая часть проекта посвящена изучению работ различных хэш-функций и выявление их преимуществ и недостатков. Необходимо исследовать поведение хэш-функций на примере работы с текстом и число коллизий в каждом отдельном случае. Все хэш-функции проверяются на тексте трагедии Уильяма Шекспира "Трагическая история о Гамлете, принце датском", представленном на анлийском языке.

### Теория
В моем проекте представлено открытое хэширование, которое представляет из себя работу со списками. Открытое хеширование или Метод цепочек – это технология разрешения коллизий, которая состоит в том, что элементы множества с равными хеш-значениями связываются в цепочку-список (можно почитать про это здесь https://intuit.ru/studies/courses/648/504/lecture/11467?page=3):

![hash][open hash]

[hash]: https://github.com/Troll0ton/Alpha_blending/blob/main/hash.jpg

---

### Сравнение хэш-функций
Для проведение сранения были выбраны 7 различных хэш-функий, отличающихся своими подходами к хэшированию данных:

---

### const hash function
Данная функция всегда возвращает 1 при любых вводных данных. Очевидно, что число коллизий в данном случае максимально, так как используется только один список из всей хэш таблицы. Данный пример полностью отражает нижнюю оценку работы всех возможных хэш-функций. Будет с чем сравнить)

![hf1][hf1]

[hf1]: https://github.com/Troll0ton/Alpha_blending/blob/main/hf1.png

### first symbol hash function
Данная функция возвращает ASCII-код первого символа всей строки. Число коллизий уменьшено по сравнению с предыдущей функцией. По ниже приведенному графику несложно догадаться, что максимумы обусловлены лишь фонетическими особенностями исходных данных. Все зависит от распространнености слов, начинающихся с определенных букв, что при особенностях работы с текстом, приводит к большому числу коллизий в отдельных вёдрах.

![hf2][hf2]

[hf2]: https://github.com/Troll0ton/Alpha_blending/blob/main/hf2.png

### length hash function
Данная хэш-функция возвращает длину получаемой строки. Заметим, что все записи лежат в самых первых вёдрах, а остальные - пусты. Это обусловлено тем, что длина слов во входном тексте (в языке) варьируется в этой области. Неэффективно, но все же лучше первой функции.  

![hf3][hf3]

[hf3]: https://github.com/Troll0ton/Alpha_blending/blob/main/hf3.png

### sum hash function
Данная хэш-функция возвращает сумму всех ASCII-кодов символов, взятой по модулю размера хэш таблицы. Опять же, работа данной хэш функции сильно будет зависеть от длин слов в исходном тексте, и при больших размерах хэш-таблиц это привёдет к малой заселенности последних вёдер. Но пока это самая лучшая хэш-функция из представленных ранее.  

![hf4][hf4]

[hf4]: https://github.com/Troll0ton/Alpha_blending/blob/main/hf4.png

### right cycle rotate hash function
Эти и последующие хэш-функции являются наиболее эффективными, так как они позволяют избежать совпадения возвращаемых значений для почти одинаковых слов, максимально неочевидны в получении результата. Изучение поведения работ таких хэш-функций требует полное исследование принципов, на которых они основаны. Но такие хэш-функции позволяют распределить записи равномерно по хэш-таблице.

![hf5][hf5]

[hf5]: https://github.com/Troll0ton/Alpha_blending/blob/main/hf5.png

### left cycle rotate hash function
Данная функция не отличается идейно от предыдущей, но на проверяемых мною данных показала лучший результат. Прослеживается зависимость числа коллизий от выбора направления циклического вращения. (слева-направо и справа-налево соответсвенно - увеличивается число коллизий). Также заметно, что влияние циклических экстремумов на распределение уменьшено. 

![hf6][hf6]

[hf6]: https://github.com/Troll0ton/Alpha_blending/blob/main/hf6.png

### super secret hash function
Проект включает и изучение работы собственно предложенной хэш-функции. Мною была выбрана полиномиальная хэш функция, которая основана на принципах хэш-суммы, но при этом вычисляется значение многочлена с заданными коэффициентами (символы в строке). Этот пример является лучшим из всех предыдущих, но и left cycle rotate hash function не сильно от него остает. 

![hf7][hf7]

[hf7]: https://github.com/Troll0ton/Alpha_blending/blob/main/hf7.png

---

## Вторая часть
Вторая часть моей работы посвящена работе с профайлером и поиском-применением оптимизаций в нужных местах. Я использовал valgrind в качестве инструмента для сбора информации по исполнению файла, callgrind для ее наглядного представления и изучения. 

Чтобы исключить влияние остальных частей программы, поиск конкретных элементов производился three hundred раз. В этом случае это позволяло максимально полно отразить картину происходящего.

### Применение AVX-инструкций
При проведении первого исследования работы программы, оказалось, что большего всего времени тратилось на сравнение текущей и требуемой строк: 
Чтобы ускорить этот процесс было решено перевести исходные данные в 256-битный формат. Это позволило использовать соответсвующие SIMD-инструкции и регистры для обработки данных: 
После проведения соответсвующих оптимизаций скорость работы программы увеличилась на 20 процентов. Оказалось, что для удобной и красивой обработки входных данных достаточно преобразовать исходные данные так, что в дальнейшем с ними было удобно оперировать. Хотя и время, которое тратится на преобразование входных данных увеличилось, время работы программы уменьшилось. Это явный пример закона Амдала. Таким образом, нам опять пригодились использование AVX-инструкций, которые хорошо подходят для обработки юольшого числа данных.

### Ассемблерные функции.
На следующем этапе оказалось, что больше всего стала весить хэш-функция. Было решено преписать ёё в ассемблерном видк и вызывать её уже в самой программе. Казалось, что компилятор не очень умный, и я смогу сделать фуекцию ещё быстрее. Но в итоге скорость работы программы уменьшилась: Не всегда попытки оптимизаций оканчиваются успехом, особенно если мы пытаемся использовать код, написанный на ассемблере.

### Использование интрисиков
Чтобы попытаться максимально ускорить работу хэш функций, было принято решение использовать интринсики. В частности, попробуем использовать CRC32: ...

---

### Вывод

![lol][me after hash table laba]

[lol]: https://github.com/Troll0ton/Alpha_blending/blob/main/lol.jpg
...


 