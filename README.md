# Hash_table
Данный проект нацелен на изучение принципов работы хэш-таблиц, сравнение различных хэш-функций и изучение их поведения на конкретных данных, развитие практических навыков при работе с профайлерами, применение оптимизаций на различных уровнях. Важной составляющей исследовательской работы является написание статьи, объёмно отражающей ход проделанной работы на всех этапах ёё проведения.

## Первая часть
Первая часть проекта посвящена изучению работ хэш-функций на примере хэш-таблиц. Необходимо исследовать эффективность работы хэш-функций на примере работы с текстом - число коллизий в каждом отдельном случае. Все хэш-функции проверяются на тексте трагедии Уильяма Шекспира "Трагическая история о Гамлете, принце датском", представленном на анлийском языке.

### Теория
В моем проекте представлено открытое хэширование, которое представляет из себя работу со списками...

Для проведение сранения были выбраны 7 различных хэш-функий, отличающихся своими методами к хэшированию данных:

### Константная хэш-функция
Данная функция всегда возвращает 1 при любых вводных данных. Очевидно, что число коллизий в данном случае максимально, так как используется только один список из всей хэш таблицы. Данный пример представляет из себя нижнюю оценку работы всех возможных хэш-функций.

### Хэш-функция, которая возвращает ASCII-код первого символа (просто имя)
Данная функция возвращает ASCII-код первого символа всей строки. Число коллизий уменьшено по сравнению с предыдущей функцией. По ниже приведенному графику несложно догадаться, что максимумы обусловлены лишь фонетическими особенностями исходных данных. Все зависит от распространнености слов, начинающихся с определенных букв, что при особенностях работы с текстом, приводит к большому числу пиков коллизий.

### Хэш-функция, ...
Данная Хэш функция возвращает длину получаемой строки. Максимум в самом начале обусловлен тем, что длина слов в тексте (в языке) варьируется в этой области. Это неэффективно, но все же лучше первой функции.  

### Хэш-сумма
Данная Хэш функция возвращает сумму всех ASCII-кодов символов, взятой по модулю размера хэш таблицы. Опять же, работа данной хэш функции сильно будет зависеть от длин слов в исходном тексте. 

### ROR
Эти и последующие хэш-функции являются наиболее эффективными, так как они позводляют избежать совпадения возвращаемых значений для почти одинаковых слов. Это являлось большой проблемой в работе всех предыдущих функций. 

### ROL
Данная функция не отличается идейно от предыдущей, но на проверяемых мною данных показала лучший результат. Прослеживается зависимость числа коллизий от выбора направления циклического вращения. (слева-направо и справа-налево соответсвенно увеличивается число коллизий)

### Моя
Проект включает и изучение работы собственно предложенной хэш-функции. Мною была выбрана полиномиальная хэш функция, которая ... Этот пример является далеко не лучшим, но так как в моей работе исследуется не эта проблема, то я счёл приемлимым эту функцию. 

## Вторая часть
Вторая часть моей работы посвящена работе с профайлером и поиском-применением оптимизаций в нужных местах. Я использовал valgrind в качестве инструмента для сбора информации по исполнению файла, callgrind для ее наглядного представления и изучения. 

Чтобы исключить влияние остальных частей программы, поиск конкретных элементов производился three hundred раз. В этом случае это позволяло максимально полно отразить картину происходящего.

### Применение AVX-инструкций
При проведении первого исследования работы программы, оказалось, что большего всего времени тратилось на сравнение текущей и требуемой строк: 
Чтобы ускорить этот процесс было решено перевести исходные данные в 256-битный формат. Это позволило использовать соответсвующие SIMD-инструкции и регистры для обработки данных: 
После проведения соответсвующих оптимизаций скорость работы программы увеличилась на 20 процентов. Оказалось, что для удобной и красивой обработки входных данных достаточно преобразовать исходные данные так, что в дальнейшем с ними было удобно пореировать. Хотя и время, которое тратится на преобразование входных данных увеличилось, время работы программы уменьшилось. Это явный пример закона Амдала. Таким образом, нам опять пригодились использование AVX-инструкций, которые хорошо подходят для обработки юольшого числа данных.

### Ассемблерные вставки.
На следующем этапе 


 